
# Start of BODY
'''
TestStruct::
testcase_id                   [int] ID of the test-case
testcase_input_path           [str] File path to test-case input
testcase_output_path          [str] File path to test-case output generated by the problem solver
testcase_expected_output_path [str] File path to test-case expected output to be matched with
testcase_error_path           [str] File path to test-case STDERR
metadata_file_paths           [list<str>] File paths to Question metadata (Extra files usually used for defining traning sets)
submission_code_path          [str] File path to submission source code
submission_language           [str] Language token of submission
testcase_result               [bool] Set to True if test-case output matches test-case expected output. Matching is done line by line
testcase_signal               [int] Exit code of the test-case process
testcase_time                 [float] Time taken by the test-case process in seconds
testcase_memory               [int] Peak memory of the test-case process determined in bytes
data                          [str] <Future use>
ResultStruct::
result      [bool]  Assign test-case result. True determines success. False determines failure
score       [float] Assign test-case score. Normalized between 0 to 1
message     [str] Assign test-case message. This message is visible to the problem solver
'''



# Start of BODY
'''
TestStruct::
testcase_id                   [int] ID of the test-case
testcase_input_path           [str] File path to test-case input
testcase_output_path          [str] File path to test-case output generated by the problem solver
testcase_expected_output_path [str] File path to test-case expected output to be matched with
testcase_error_path           [str] File path to test-case STDERR
metadata_file_paths           [list<str>] File paths to Question metadata (Extra files usually used for defining traning sets)
submission_code_path          [str] File path to submission source code
submission_language           [str] Language token of submission
testcase_result               [bool] Set to True if test-case output matches test-case expected output. Matching is done line by line
testcase_signal               [int] Exit code of the test-case process
testcase_time                 [float] Time taken by the test-case process in seconds
testcase_memory               [int] Peak memory of the test-case process determined in bytes
data                          [str] <Future use>
ResultStruct::
result      [bool]  Assign test-case result. True determines success. False determines failure
score       [float] Assign test-case score. Normalized between 0 to 1
message     [str] Assign test-case message. This message is visible to the problem solver
'''

import re
import sys
import math
import os
import random




def neighbors(i , j) :
    """ find neighbors of a point"""
    ns = []
    # vector de direction
    dx = [+1, +1,  0, 1]
    dy = [0,  +1, 1,  -1]
    for d in range(4) :
        ns.append((i + dx[d], j + dy[d]))
    #remove neagative element
    ns = [i for i in ns if i[0] >= 0 and i[1] >= 0]
    return ns

def search(m, L, P, c) :
    
    c.append((L,P))
    Nset = neighbors(L, P)
    # remove out of range index
    Nset = [i for i in Nset if i[0] < len(m) and i[1] < len(m[0])]
    for  LP in Nset :
        if m[LP[0]][LP[1]] == 1:
            c = search(m, LP[0],LP[1], c)
    return c

def valid(t, comp) :
    """verify if a point is already visited"""
    for element in comp :
        if t in element :
            return False
    return True

def find_c(m):
    comp = []
    for L in range(len(m)) :
        for P in range(len(m[0])) :
            if m[L][P] == 1  and valid((L,P), comp):
                comp.append(search(m, L, P, []))
    return comp

def is_vert(e) :
    """verify if boat is vertical """
    f = e[0][0]
    for t in e :
        if f != t[0] :
            return False
    return True

def is_hori(e) :
    """verify if boat is horizantal """
    f = e[0][1]
    for t in e :
        if f != t[1] :
            return False
    return True

def check(m) :
    """check if the matrice is valid"""
    #find Connected-component
    lst = find_c(m)
    for e in lst :
        # verify len , 3 is the len of large boat
        if len(e) > 3 :
            return False
        if not is_vert(e) and  not is_hori(e):
            return False
    return True

def sumLigne(output):
    s = []
    for l in output:
        s.append(sum(l))
    return s


def sumColumne(output):
    s = []
    
    for j in range(len(output[0])):
        r = 0
        for i in range(len(output)):
            r = r + output[i][j]
        s.append(r)
    return s

def checkSum(output,arg1,arg2):
    a1 = sumLigne(output)
    a2 = sumColumne(output)
    return a1 == arg1 and a2 ==arg2


def run_custom_checker(t_obj, r_obj):
    # Don't print anything to STDOUT in this function
    # Enter your custom checker scoring logic here
    result_data = ''
    try:
        result_data = open(t_obj.testcase_output_path, 'r').read()
    except IOError:
        r_obj.result = False
        r_obj.score = 0
        r_obj.message = 'Error reading result file'
        return
    
    
    try:
        arg = open(t_obj.testcase_input_path, 'r').read()
    except IOError:
        r_obj.result = False
        r_obj.score = 0
        r_obj.message = 'Error reading arguments file'
        print("Error in arrguments file")
        return
    
    lst = [l.rstrip() for l in result_data.split('\n')]
    lst = [i.split(' ') for i in lst]
    while [''] in lst:
        lst.remove([''])
    output = [list(map(int,l)) for l in lst]

    arg = [l.rstrip() for l in arg.split('\n')]
    arg = [i.split(' ') for i in arg]
    while [''] in arg:
        arg.remove([''])
    arg = [list(map(int,l)) for l in arg]
    if check(output) and checkSum(output,arg[0],arg[1]):
        r_obj.result = True
        r_obj.score = 1
        r_obj.message = 'valid solution'
        return
    else:
        r_obj.result = False
        r_obj.score = 0
        r_obj.message = 'Not a valid solution'
        return
    
# End of BODY
        

# End of BODY
        